<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>继承</title>
</head>
<body>
  
</body>
<script>
    {
    // 原型链继承

    //复制父类的属性和方法来重写子类原型对象

    function fatherFn () {
      this.some = '父类的this属性';
    }
    fatherFn.prototype.fatherFnSome = '父类原型对象上属性或者方法';

    // 子类
    function sonFn () {
      this.obkoro1 = '子类的this属性';
    }
    // 核心步骤，重写子类的原型对象
    sonFn.prototype = new fatherFn(); //将fatherFn的实例赋值给sonFn的prototype
    sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法'; //子类的属性或者方法声明在后面，避免被覆盖
    // 实例化子类
    let sonFnInstance = new sonFn();

    console.log('子类的实例', sonFnInstance);

    // 理解 new 做了什么
    /**
     * 1. 创建了一个全新的对象。
     * 2. 这个新对象的原型(__proto__)指向函数的prototype对象。
     * 3. 执行函数，函数的this会绑定在新创建的对象上。
     * 4. 如果没有返回其他对象（包括数组、函数、日期对象等），那么会自动返回这个新对象。
     * 5. 返回的那个对象为构造函数的实例。
     * 
    */
    // 原型链继承的缺点
    
    // 1. 父类使用 this 声明的属性被所有实例共享
    // 2. 创建子类实例时，无法向父类构造函数传递参数，不够灵活。 


    }

    {
      //  构造调用函数返回其他对象
      // 返回其他对象会导致获取不到构造函数的实例，很容易因此引起意外问题。
      function fatherFn () {
        this.some = '父类的this属性';
        return {
          name : 'fqt',
          age:27
        }
      }
      fatherFn.prototype.fatherFnSome = '父类原型对象上属性或者方法';

      // 子类
      function sonFn () {
        this.obkoro1 = '子类的this属性';
      }
      // 核心步骤，重写子类的原型对象
      sonFn.prototype = new fatherFn(); //将fatherFn的实例赋值给sonFn的prototype
      sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法'; //子类的属性或者方法声明在后面，避免被覆盖
      // 实例化子类
      let sonFnInstance = new sonFn();

      console.log('子类的实例', sonFnInstance);
    }

    {
      // 借用构造函数继承(call)

      function fatherFn (...arr) {
        this.some = '父类的this属性';
        this.params = arr; //父类的参数
      }
      fatherFn.prototype.fatherFnSome = '父类原型对象的属性或者方法';

      function sonFn (fatherParams, ...sonParams) {
        fatherFn.call(this, ...fatherParams); //核心步骤: 将fatherFn的this指向sonFn的this对象上
        this.obkorol = '子类的this属性';
        this.sonParams = sonParams; //子类传参数
      }
      sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法';
      let fatherParamsArr = ['父类的参数1', '父类的参数2'];
      let sonParamsArr = ['子类的参数1', '子类的参数2'];
      const sonFnInstance = new sonFn(fatherParamsArr, ...sonParamsArr);
      console.log('借用构造函数子类实例', sonFnInstance);

      /**
       * 借用构造函数继承做了什么
       * 声明类，组织参数等，只是辅助的上下文代码，核心是借用构造函数使用call做了什么。
       * 一经调用 call/apply 他们就会立即执行函数，并在函数执行时改变函数的 this 指向。
       * 1. 在子类中使用call调用父类， fatherFn 将会被立即执行，并且将fatherFn函数的this指向 sonFn的this
       * 2. 因为函数执行了，所以fatherFn使用的this声明的函数都会被声明到sonFn的this对象下。
       * 3. 实例化子类，this将指向new期间创建的新对象，返回该新对象。
       * 4. 对 fatherFn.prototype 没有任何操作，无法继承。
       * 
       * 
       * 借用构造函数继承的有缺点
       * 优点：1.可以向父类传递参数。2.解决了原型链继承中：父类属性使用this声明属性会在所有实例共享的问题。
       * 缺点：1. 只能继承父类通过this声明的属性/方法，不能继承父类 prototype 上的属性、方法。
       *      2. 父类方法无法复用：因为无法继承父类的prototype，所以每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此方法无法复用。
       * 
       * 
      */
    }

    {
      // 组合式继承(call + new );
      function fatherFn (...arr) {
        this.some = '父类的this属性';
        this.params = arr; //父类的参数
      }
      fatherFn.prototype.fatherFnSome = '父类原型对象的属性或者方法';
      function sonFn () {
        fatherFn.call(this, '借用构造函数继承', '第二次调用'); //借用构造继承：继承父类通过this声明属性和方法至子类实例的属性上
        this.obkoro1 = '子类的this属性';
      }
      sonFn.prototype = new fatherFn('原型链继承', '第一次调用'); // 原型链继承：将 this 和 prototype 声明的属性/方法继承至子类的prototype上
      sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法';
      const sonFnInstance = new sonFn();
      console.log('组合式继承子类实例', sonFnInstance);
      /*
      * 组合继承的优缺点
        优点: 完整继承
              1. 父类通过this声明属性、方法被子类实例共享的问题（原型链继承的问题）每次实例化子类将重新初始化父类通过this声明属性
              实例根据原型链查找规则，每次都会。
              2. 父类通过prototype声明属性、方法无法继承的问题（借用构造函数问题）。
        缺点: 
              1.两次调用父类函数（new fatherFn() 和 fatherFn.call(this)）,造成一定的性能损耗。
              2. 因调用两次父类，导致父类通过this 声明属性、方法，生成两份问题。
              3. 原型链上下文丢失：子类和父类通过prototype声明的属性、方法都存在子类的prototype上 
      **/
    }
</script>
</html>